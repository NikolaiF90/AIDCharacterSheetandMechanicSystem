# CSMS Technical Notes

## AID Environment Discoveries

### globalThis dump (beta, Feb 2026)
```
"global"
"log"           â† native shorthand for console.log
"sandboxConsole"
"storyCards"    â† direct array manipulation works
"worldInfo"
"updateStoryCards"  â† native but unreliable, use storyCards directly
"updateState"       â† native but behavior unclear, use state directly
"state"
"memory"        â† separate from state.memory, don't write to this
"text"
"info"
"history"
```

### Key Findings
- `log()` is a native global shorthand for `console.log()`
- `storyCards.push()` works for creation, direct mutation works for updates
- `updateStoryCards` â€” tested, unreliable. Stick to direct `storyCards` manipulation
- `updateState` â€” tested, doesn't reflect changes. Use `state.x = y` directly
- `memory` global and `state.memory` are SEPARATE objects. Only write to `state.memory`
- Input text always has newline prefix â€” always `.trim()` before processing
- Script doesn't run if AI stutters/lags â€” player must retry, nothing we can do
- `.includes()` works fine on strings as long as values are sanitized with `|| ""`
- New storyCards pushed mid-output don't appear in UI until next action â€” AID rendering quirk
- Library functions show up in `globalThis` â€” confirmed by testing `rollDice`

### state.memory
- `state.memory.context` â€” write to this to override Plot Essentials
- `state.memory.authorsNote` â€” write to this to override Author's Note
- `state.memory.frontMemory` â€” injected before last action, invisible to player
- Both readable and writable confirmed

### storyCard object structure
```js
{
  id: "542586357",              // auto-assigned by AID
  createdAt: "2026-02-23...",   // auto-assigned
  updatedAt: "2026-02-23...",   // auto-assigned
  keys: "keyword1, keyword2",
  entry: "card content here",
  type: "class",                // "class" = default, or custom string e.g "1- Species"
  title: "Card Title",
  description: "Notes field â€” shown to player during character creation",
  useForCharacterCreation: false  // true = card appears as selectable option in character creator scenarios
}
```

### Scenario Types (AID)
- **Classic** â€” standard adventure, PE supports `${placeholder}` template syntax for player input
- **Multi-choice** â€” player selects from creator-defined paths, each with different story openings
- **Character creator** â€” player builds character by selecting story card options, story starts blank
  - Cards with `useForCharacterCreation: true` appear as options
  - Selected options get written to Plot Essentials automatically
  - Classic scenario with PE templates gives MORE control â€” preferred for CSMS

### Multiplayer Findings (tested Feb 2026)
- `info.characters` returns **array of strings**, NOT array of objects
  - Documentation says `[{ name: "Sam" }]` â€” THIS IS WRONG
  - Actual format: `["Nikolai", "Datwangye"]`
- `info.characters` can contain empty strings â€” always guard with `!charName || charName.trim() === ""`
- All players default to name "You" on join â€” must change manually
- Third Person plot component switches input format from `> You` to `> Name`
- All players see the same output in real-time
- Host model settings apply to all players
- Name changes mid-session don't sync instantly across all screens â€” AID UI lag
- Input format in third person: `\n> CharacterName action here`

### AI Instruction Injection (Lessons Learned)
Tested multiple methods for getting AI to produce structured output mid-story:

| Method | Result | Why |
|---|---|---|
| `frontMemory` injection | âŒ Ignored | AID positions it AFTER player action â€” AI already committed to narrating |
| `text` manipulation | âŒ Ignored | Treated as story continuation, not system instruction |
| `authorsNote` | âš ï¸ Don't touch | World maker territory â€” would overwrite their notes |
| Story card entry (keyword match) | âœ… Works | AI treats as established world fact â€” highest priority |
| Context hook `##` instruction at end of text | âœ… Works | AI reads as direct instruction before generating |

**Key insight:** For roll stat detection, `##` injected at the END of context (after all story text) works because AI reads sequentially â€” it sees the instruction right before it generates. For tag system stat detection, same principle applies via frontMemory positioned correctly.

### Known Bugs / Limitations
- `stop: true` in input modifier also suppresses player action from displaying
- Script Test panel unreliable â€” use PLAY + INSPECT workflow instead
- LMI and logs expire after a few minutes â€” keep second tab open while testing
- `updateWorldEntry` throws error if index doesn't exist (no longer silent)
- Inspect panel (Last AI Call) unreliable â€” use `log()` to verify frontMemory injection
- New storyCards pushed in output hook don't appear in UI until next player action
- Harbinger model occasionally outputs extra text alongside stat word â€” stat regex catches it anyway

---

## Design Decisions

### Why `state.characters[]` array instead of `state.character`
Multiple characters needed â€” player + NPCs. Array allows `find()`, `findIndex()`, iteration. Single object would require separate storage per character.

### Why `storedName` in handleReset
Player might type "JonaTHan" â€” `findCharacter()` finds it case-insensitively but `removeCharacterCard()` does exact title match. Always use the stored name from state for card operations.

### Why bracketed notifications `[...]`
AI treats bracketed content as out-of-character notes â€” sees it but doesn't narrate it directly. Established AID convention (same as `[Author's note:]`). Keeps narrative clean.

### Why regex scan instead of startsWith for commands
AID prepends `> You` or `> You say, "..."` to do/say inputs. Format changes between versions. Scanning entire input for `/csms` pattern anywhere is future-proof and format-agnostic.

### Why position-based parsing in parseCharacterCard
Reading values by position instead of label means player can rename any label without breaking the parser. `srt: 14` still gives us `14` for STR. Label is irrelevant â€” structure is what matters.

### Why `\S+` instead of `\d+` in parseCharacterCard regex
`\d+` fails silently if player types `ee` for a stat value â€” entire line match returns null and `safeInt` never gets called. `\S+` captures anything, lets `safeInt` handle validation and error reporting properly.

### Why `isMultiplayerCharacter` flag
Without it, `syncMultiplayerCharacters()` would delete NPC sheets when they're not in `info.characters`. Flag ensures only actual multiplayer player sheets get synced against the player list.

### Why compact injection format for frontMemory
Full character sheets in frontMemory would consume too much context. One-line format `[CSMS|Name|HP:x/y|AC:z|...]` gives AI all mechanical data it needs in minimum tokens. 20 characters Ã— ~60 chars = ~1200 chars â€” very manageable.

### Why keyword system was deprioritized
AID's native keyword system is unreliable for cross-script compatibility. Direct `frontMemory` injection gives us full control over what the AI sees and when. No keyword conflicts possible.

### Why `state.csmsPending` is a single-item queue
AI generation happens one at a time â€” we hijack the entire output for stat generation. Processing multiple simultaneously would cause chaos. One per action is intentional. Multiple tagged cards process sequentially over consecutive actions.

### Why player agency instead of automatic roll detection
Attempted to have AI automatically signal rolls via `[ROLL:XdY+STAT]` tags. Failed â€” AI ignored all instruction injection methods tested (frontMemory, text manipulation). Player saying `/csms roll` is explicit and reliable. Aligns with TTRPG philosophy: player declares intent to roll, AI determines what stat, script produces the number.

### Why `##` format for roll instructions
`##` signals to the AI that this is a direct instruction (not story content). Injected at end of context so AI reads it immediately before generating. Two-action flow: action 1 gets the stat, action 2 gets the narrative informed by the result.

### Why NotifyThem is separate from CSMS
Independent reusability â€” other scripters can use NotifyThem without CSMS. Publishable as standalone system. Clean separation of concerns.

---

## Command Architecture

```
Player input (any format)
    â†“
Input hook â€” regex scan for /csms anywhere in text
    â†“
parseCommand() â€” split on "/" â†’ action, args1, args2, args3
    â†“
handle[Action](args1, args2, args3) â€” execute, return result string
    â†“
notify(result) â€” store in state.notifyMessages
    â†“
Original player text passes to AI unchanged
    â†“
Context hook â€” parseCharacterCard + injectActiveCharacters + syncMultiplayerCharacters + processTaggedCards
              + stat question injection (if csmsRollPending)
    â†“
AI generates narrative (or stat response if csmsPending/csmsRollPending)
    â†“
Output hook â€” generateNarrativeSheet() + rollCheck() + updateNotification()
    â†“
Player sees: [CSMS notification] + AI narrative (or ## instruction if roll pending)
```

### Command Syntax (v1.5.0+)
```
/csms create/Name
/csms stats/Name
/csms sync/Name
/csms reset/Name
/csms cleanup
/csms roll/Caller/action          â† solo roll
/csms roll/Caller/action/Opponent â† opposed roll (Opponent uppercase = NPC, lowercase = object)
```

### Slash-arg Rules
- Args split on `/` â€” multi-word args work naturally: `/csms roll/Nikolai/pick the lock/safe`
- Uppercase arg3 = living NPC â†’ script searches for character sheet, errors if not found
- Lowercase arg3 = object â†’ solo roll, no sheet search, AI judges outcome vs context
- Missing arg3 = solo roll

---

## Roll Flow

```
Player: > You punch the thug /csms roll/Nikolai/punch/Thug
  â†“
Input hook â€” strips /csms roll/Nikolai/punch/Thug
handleRoll() â€” caller=Nikolai, action=punch, opponent=Thug (uppercase = NPC)
findCharacter(Thug) â†’ found â†’ set state.csmsRollPending = { caller, action, oppose }
  â†“
Context hook â€” detects csmsRollPending, oppose is set
Appends:
## Reply with exactly two lines.
Line 1: most relevant stat for Nikolai to "punch": STR, DEX, CON, INT, WIS, or CHA.
Line 2: most relevant stat for Thug to oppose this: STR, DEX, CON, INT, WIS, or CHA.
  â†“
AI responds: "STR\nSTR" (or any two stats)
  â†“
Output hook â€” rollCheck() detects csmsRollPending
Parses callerStat=STR, opposeStat=STR
resolveRoll("1d20+STR", Nikolai) â†’ { total: 16, breakDown: "..." }
resolveRoll("1d20+STR", Thug)   â†’ { total: 9,  breakDown: "..." }
finalResult = 16 - 9 = 7
Nikolai wins â†’ resolveDamage(Nikolai, 7) â†’ 1d6+7 = [3]+7 = 10
applyDamage(Thug, 10) â†’ Thug HP updated â†’ updateCharacterCard(Thug)
notify(full breakdown)
text = "## Continue the story. Nikolai attempted to punch. Nikolai rolled 16 against 9 of Thug. Nikolai wins and 10 damage applied to Thug. Thug left with X HP."
state.csmsRollPending = null
  â†“
Player presses Continue
  â†“
AI reads ## instruction â†’ narrates punch outcome informed by roll result
```

### Solo Roll Flow
```
Player: > You pick the lock /csms roll/Nikolai/pick the lock
  â†“
handleRoll() â€” no arg3 â†’ oppose = null â†’ state.csmsRollPending = { caller, action, oppose: null }
  â†“
Context hook â€” single ## line asking for one stat
  â†“
AI responds: "DEX"
  â†“
Output hook â€” rollCheck() solo branch
resolveRoll("1d20+DEX", Nikolai) â†’ result
notify(breakdown)
text = "## Continue the story. Nikolai attempted to pick the lock. Nikolai rolled 14."
  â†“
AI narrates â€” judges success/failure by context (bank safe vs bathroom cabinet)
```

---

## Tag System Flow

```
World maker creates: [CSMS] Mira card with description entry
    â†“
Context hook â€” processTaggedCards() finds [CSMS] Mira
    â†“
Check recent history â€” does "Mira" appear?
    â†“
YES â€” check for existing CS
    â†“
No CS found â€” set state.csmsPending = "Mira"
Inject stat generation prompt into frontMemory
    â†“
AI responds with: STR:x DEX:x CON:x INT:x WIS:x CHA:x HP:x AC:x
    â†“
Output hook â€” generateNarrativeSheet() detects csmsPending
Parse stats, create character, updateCharacterCard()
Remove [CSMS] tag from original card
Strip stat string from visible output
Clear state.csmsPending
    â†“
Player sees: [Character sheet generated for Mira!] + normal narrative
```

---

## Compatibility Notes

### Inner Self (LewdLeah)
- IS uses `storyCards` directly â€” compatible
- IS uses `state` â€” compatible, use namespaced keys (`state.characters` not `state.char`)
- IS uses `state.memory` â€” compatible, don't overwrite IS memory fields
- Architecture mirrors IS pattern (`InnerSelf("input")` â†’ `CSMS("input")`)
- IS scans history for character triggers â€” same approach as our `LOOKBACK_ACTIONS`

### Auto-Cards
- AC generates cards by character name keywords â€” potential overlap
- Current mitigation: `csms_cs_${name}` prefix on card keys
- Better solution: direct `frontMemory` injection (implemented) makes keyword matching irrelevant
- Tag system works WITH AC â€” AC generates a card, world maker adds `[CSMS]` tag, CSMS generates sheet

### General compatibility rule
- Always namespace state variables: `state.characters`, `state.notifyMessages` etc
- Never use generic keys that other scripts might use
- `ğŸ“‹` emoji prefix on card titles â€” distinctive enough to avoid conflicts

---

## File Structure
```
src/
  library.js        â€” Main script (NotifyThem + CSMS)
assets/
  Notes.MD          â€” This file
  Milestones.MD     â€” Phase tracking
  Changelog.MD      â€” Version history
  images/
    CSMS_CoverArt.png
README.md           â€” Public documentation
```

---

## Feat System Design (Planned)

### Philosophy
Feats are written in natural language by world makers â€” conditions, faction checks, contextual rules. Script cannot parse intent. AI can. Clean boundary:
- **Script's job:** detect feat usage, inject feat card entry into context, execute any dice rolls, apply damage
- **AI's job:** read feat rules, judge conditions, decide formula, narrate outcome

### Feat Card Format
World maker writes feat as a story card. Entry is free-form natural language. No fixed structure required. Example:
```
Tactical Reinforcement:
When engaged in combat, the player may call for reinforcements once per combat.
Allies arriving = XdY + X.
X = 1 (other faction territory), 2 (neutral), 3 (allied).
Y = 2 * player's Wisdom modifier.
Output the roll breakdown before narrating outcome.
Player must belong to a faction.
```

### Script-AI Contract for Feat Rolls
AI reads feat rules and decides the formula. AI outputs it in a parseable tag:
```
[ROLL:XdY+Z]     â† any valid dice notation e.g. [ROLL:3d6+2] or [ROLL:1d8+WIS]
[DAMAGE:XdY+Z]   â† damage application e.g. [DAMAGE:2d4+1]
```

Script parses the tag â†’ calls `resolveRoll()` â†’ applies result â†’ feeds result back to AI â†’ AI narrates.

`resolveRoll()` already handles arbitrary notation â€” feat system gets the dice engine for free.

### Blame Policy
If AI feeds a valid formula with wrong numbers â€” that's the feat writer's problem, not the script's. Script's contract is: **if the formula is valid, we calculate it. Period.** ğŸ˜„

### Why `resolveDamage()` is a wrapper
Feat damage calls `resolveDamage()` with whatever the AI fed â€” no special casing needed in the feat system. Feat bonuses and proficiency checks slot in here when feats ship.

### Command (planned)
```
/csms feat/FeatName
```
Script finds feat card â†’ injects entry into frontMemory/context â†’ AI executes rules â†’ script handles any [ROLL:] or [DAMAGE:] tags in output.

### Open Questions
- Tag format final decision: `[ROLL:XdY+Z]` vs `[CSMS:ROLL:XdY+Z]` â€” namespaced safer?
- Once-per-combat tracking â€” script tracks combat state, or trust AI?
- Multiple feat rolls in one output â€” process sequentially or all at once?

---

## Opposed Roll Design (Implemented â€” v1.5.0)

### Why it's needed
Current system is player-centered â€” only player rolls. Without opposed rolls, NPC attacks have no mechanical weight. HP never updates from NPC actions. A failed dodge roll is just AI vibes, not a real hit.

Opposed roll closes the loop:
- Player rolls DEX (dodge) â†’ 6
- Guard rolls STR (attack) â†’ 15
- Guard wins by 9 â†’ hit confirmed by script, HP updates, AI narrates

### Proposed AI response format
Two separate `##` instructions, each asking for one thing:

```
## Reply with only one word â€” the most relevant stat for "{action}": STR, DEX, CON, INT, WIS, or CHA.
## If this action is contested by an NPC, reply OPPOSED:NPCName (first name only). If not, reply SOLO.
```

AI responds on two lines:
```
DEX
OPPOSED:Guard
```

### Why two separate blocks instead of pipe format
Pipe format `DEX | true | Guard` is too complex â€” AI adds narrative, ignores format, hallucinates fields. Proven from tag system experience. Single-concept responses per line are what reliably survives.

### Parsing
```js
const opposedMatch = text.match(/OPPOSED:(\w+)/i);
const isOpposed = !!opposedMatch;
const npcName = opposedMatch ? opposedMatch[1] : null;
// SOLO or anything without OPPOSED: = simple roll, current flow unchanged
```

### Open questions
- What if NPC name has spaces (Guard Captain)? `\w+` breaks â€” instruction says first name only as mitigation
- After script determines winner â€” does HP update automatically or just feed result to AI?
- DC checks (fixed threshold) still undesigned â€” park until after opposed rolls ship

### DC vs AC vs Opposed (quick reference)
| Type | Example | Both sides roll? |
|---|---|---|
| DC check | Pick a lock (DC 15) | âŒ Player rolls vs fixed number |
| AC check | Attack someone | âŒ Attacker rolls vs defender's static AC |
| Opposed roll | Dodge a punch | âœ… Both sides roll, higher wins |

Opposed roll is the priority â€” it's what makes NPC actions mechanically real.
