# CSMS Technical Notes

## AID Environment Discoveries

### globalThis dump (beta, Feb 2026)
```
"global"
"log"           â† native shorthand for console.log
"sandboxConsole"
"storyCards"    â† direct array manipulation works
"worldInfo"
"updateStoryCards"  â† native but unreliable, use storyCards directly
"updateState"       â† native but behavior unclear, use state directly
"state"
"memory"        â† separate from state.memory, don't write to this
"text"
"info"
"history"
```

### Key Findings
- `log()` is a native global shorthand for `console.log()`
- `storyCards.push()` works for creation, direct mutation works for updates
- `updateStoryCards` â€” tested, unreliable. Stick to direct `storyCards` manipulation
- `updateState` â€” tested, doesn't reflect changes. Use `state.x = y` directly
- `memory` global and `state.memory` are SEPARATE objects. Only write to `state.memory`
- Input text always has newline prefix â€” always `.trim()` before processing
- Script doesn't run if AI stutters/lags â€” player must retry, nothing we can do
- `.includes()` works fine on strings as long as values are sanitized with `|| ""`
- New storyCards pushed mid-output don't appear in UI until next action â€” AID rendering quirk
- Library functions show up in `globalThis` â€” confirmed by testing `rollDice`

### state.memory
- `state.memory.context` â€” write to this to override Plot Essentials
- `state.memory.authorsNote` â€” write to this to override Author's Note
- `state.memory.frontMemory` â€” injected before last action, invisible to player
- Both readable and writable confirmed

### storyCard object structure
```js
{
  id: "542586357",              // auto-assigned by AID
  createdAt: "2026-02-23...",   // auto-assigned
  updatedAt: "2026-02-23...",   // auto-assigned
  keys: "keyword1, keyword2",
  entry: "card content here",
  type: "class",                // "class" = default, or custom string e.g "1- Species"
  title: "Card Title",
  description: "Notes field â€” shown to player during character creation"
  useForCharacterCreation: false  // true = card appears as selectable option in character creator scenarios
}
```

### Scenario Types (AID)
- **Classic** â€” standard adventure, PE supports `${placeholder}` template syntax for player input
- **Multi-choice** â€” player selects from creator-defined paths, each with different story openings
- **Character creator** â€” player builds character by selecting story card options, story starts blank
  - Cards with `useForCharacterCreation: true` appear as options
  - Selected options get written to Plot Essentials automatically
  - Classic scenario with PE templates gives MORE control â€” preferred for CSMS

### Multiplayer Findings (tested Feb 2026)
- `info.characters` returns **array of strings**, NOT array of objects
  - Documentation says `[{ name: "Sam" }]` â€” THIS IS WRONG
  - Actual format: `["Nikolai", "Datwangye"]`
- `info.characters` can contain empty strings â€” always guard with `!charName || charName.trim() === ""`
- All players default to name "You" on join â€” must change manually
- Third Person plot component switches input format from `> You` to `> Name`
- All players see the same output in real-time
- Host model settings apply to all players
- Name changes mid-session don't sync instantly across all screens â€” AID UI lag
- Input format in third person: `\n> CharacterName action here`

### AI Instruction Injection (Lessons Learned)
Tested multiple methods for getting AI to produce structured output mid-story:

| Method | Result | Why |
|---|---|---|
| `frontMemory` injection | âŒ Ignored | AID positions it AFTER player action â€” AI already committed to narrating |
| `text` manipulation | âŒ Ignored | Treated as story continuation, not system instruction |
| `authorsNote` | âš ï¸ Don't touch | World maker territory â€” would overwrite their notes |
| Story card entry (keyword match) | âœ… Works | AI treats as established world fact â€” highest priority |
| Context hook `##` instruction at end of text | âœ… Works | AI reads as direct instruction before generating |

**Key insight:** `##` injected at the END of context works because AI reads sequentially â€” it sees the instruction right before it generates. This is the reliable method for structured output requests.

### Known Bugs / Limitations
- `stop: true` in input modifier also suppresses player action from displaying
- Script Test panel unreliable â€” use PLAY + INSPECT workflow instead
- LMI and logs expire after a few minutes â€” keep second tab open while testing
- `updateWorldEntry` throws error if index doesn't exist (no longer silent)
- Inspect panel (Last AI Call) unreliable â€” use `log()` to verify frontMemory injection
- New storyCards pushed in output hook don't appear in UI until next player action
- Harbinger model occasionally outputs extra text alongside stat word â€” stat regex catches it anyway

---

## Design Decisions

### Why `state.characters[]` array instead of `state.character`
Multiple characters needed â€” player + NPCs. Array allows `find()`, `findIndex()`, iteration. Single object would require separate storage per character.

### Why `storedName` in handleReset
Player might type "JonaTHan" â€” `findCharacter()` finds it case-insensitively but `removeCharacterCard()` does exact title match. Always use the stored name from state for card operations.

### Why bracketed notifications `[...]`
AI treats bracketed content as out-of-character notes â€” sees it but doesn't narrate it directly. Established AID convention (same as `[Author's note:]`). Keeps narrative clean.

### Why regex scan instead of startsWith for commands
AID prepends `> You` or `> You say, "..."` to do/say inputs. Format changes between versions. Scanning entire input for `/csms` pattern anywhere is future-proof and format-agnostic.

### Why position-based parsing in parseCharacterCard
Reading values by position instead of label means player can rename any label without breaking the parser. `srt: 14` still gives us `14` for STR. Label is irrelevant â€” structure is what matters.

### Why `\S+` instead of `\d+` in parseCharacterCard regex
`\d+` fails silently if player types `ee` for a stat value â€” entire line match returns null and `safeInt` never gets called. `\S+` captures anything, lets `safeInt` handle validation and error reporting properly.

### Why `isMultiplayerCharacter` flag
Without it, `syncMultiplayerCharacters()` would delete NPC sheets when they're not in `info.characters`. Flag ensures only actual multiplayer player sheets get synced against the player list.

### Why compact injection format for frontMemory
Full character sheets in frontMemory would consume too much context. One-line format `[CSMS|Name|HP:x/y|AC:z|...]` gives AI all mechanical data it needs in minimum tokens.

### Why keyword system was deprioritized
AID's native keyword system is unreliable for cross-script compatibility. Direct `frontMemory` injection gives us full control over what the AI sees and when. No keyword conflicts possible.

### Why `state.csmsPending` is a single-item queue
AI generation happens one at a time â€” we hijack the entire output for stat generation. Processing multiple simultaneously would cause chaos. One per action is intentional. Multiple tagged cards process sequentially over consecutive actions.

### Why player agency instead of automatic roll detection
Attempted to have AI automatically signal rolls via tags. Failed â€” AI ignored all instruction injection methods tested. Player saying `/csms roll` is explicit and reliable. Aligns with TTRPG philosophy: player declares intent to roll, AI determines what stat, script produces the number.

### Why `##` format for roll instructions
`##` signals to the AI that this is a direct instruction, not story content. Injected at end of context so AI reads it immediately before generating.

### Why NotifyThem is separate from CSMS
Independent reusability â€” other scripters can use NotifyThem without CSMS. Publishable as standalone system. Clean separation of concerns.

### Why inventory lives in CS notes field, not a separate card
No character limit unlike Entry (2000 char ceiling). Keeps inventory naturally paired with character stats. No extra cards cluttering world info. Multiplayer compatible by default â€” each character already has their own CS card. Player editable without script intervention.

### Why inventory uses dash list format
Dash-separated items are read by AI as distinct entries more reliably than newline alone. AID players are already comfortable with bullet list formatting. Script parses cleanly â€” each `- item` line is one array element.

### Why duplicate items are separate lines, not `x3` notation
Simpler parsing. No quantity tracking complexity for MVP. Equivalent to a standard JS array with duplicate entries. Player has full manual control over each instance. Can be revisited in a later phase.

---

## Command Architecture

```
Player input (any format)
    â†“
Input hook â€” regex scan for /csms anywhere in text
    â†“
parseCommand() â€” split on "/" â†’ action, args1, args2, args3
    â†“
handle[Action](args1, args2, args3) â€” execute, return result string
    â†“
notify(result) â€” store in state.notifyMessages
    â†“
Original player text passes to AI unchanged
    â†“
Context hook â€” parseCharacterCard + injectActiveCharacters + syncMultiplayerCharacters + processTaggedCards
              + stat question injection (if csmsRollPending)
    â†“
AI generates narrative (or stat response if csmsPending/csmsRollPending)
    â†“
Output hook â€” generateNarrativeSheet() + rollCheck() + updateNotification()
    â†“
Player sees: [CSMS notification] + AI narrative (or ## instruction if roll pending)
```

### Command Syntax (v1.5.0+)
```
/csms create/Name
/csms stats/Name
/csms sync/Name
/csms reset/Name
/csms cleanup
/csms roll/Caller/action          â† solo roll
/csms roll/Caller/action/Opponent â† opposed roll (Opponent uppercase = NPC, lowercase = object)
/csms update/stats/Name           â† sync stats from CS entry field
/csms update/inventory/Name       â† sync inventory from CS notes field
```

### Slash-arg Rules
- Args split on `/` â€” multi-word args work naturally: `/csms roll/Nikolai/pick the lock/safe`
- Uppercase arg3 = living NPC â†’ script searches for character sheet, errors if not found
- Lowercase arg3 = object â†’ solo roll, no sheet search, AI judges outcome vs context
- Missing arg3 = solo roll

---

## Roll Flow

```
Player: > You punch the thug /csms roll/Nikolai/punch/Thug
  â†“
Input hook â€” strips /csms roll/Nikolai/punch/Thug
handleRoll() â€” caller=Nikolai, action=punch, opponent=Thug (uppercase = NPC)
findCharacter(Thug) â†’ found â†’ set state.csmsRollPending = { caller, action, oppose }
  â†“
Context hook â€” detects csmsRollPending, oppose is set
Appends:
## Reply with exactly two lines.
Line 1: most relevant stat for Nikolai to "punch": STR, DEX, CON, INT, WIS, or CHA.
Line 2: most relevant stat for Thug to oppose this: STR, DEX, CON, INT, WIS, or CHA.
  â†“
AI responds: "STR\nSTR" (or any two stats)
  â†“
Output hook â€” rollCheck() detects csmsRollPending
Parses callerStat=STR, opposeStat=STR
resolveRoll("1d20+STR", Nikolai) â†’ { total: 16, breakDown: "..." }
resolveRoll("1d20+STR", Thug)   â†’ { total: 9,  breakDown: "..." }
finalResult = 16 - 9 = 7
Nikolai wins â†’ resolveDamage(Nikolai, 7) â†’ 1d6+7 = [3]+7 = 10
applyDamage(Thug, 10) â†’ Thug HP updated â†’ updateCharacterCard(Thug)
notify(full breakdown)
text = "## Continue the story. Nikolai attempted to punch. Nikolai rolled 16 against 9 of Thug. Nikolai wins and 10 damage applied to Thug. Thug left with X HP."
state.csmsRollPending = null
  â†“
Player presses Continue
  â†“
AI reads ## instruction â†’ narrates punch outcome informed by roll result
```

### Solo Roll Flow
```
Player: > You pick the lock /csms roll/Nikolai/pick the lock
  â†“
handleRoll() â€” no arg3 â†’ oppose = null â†’ state.csmsRollPending = { caller, action, oppose: null }
  â†“
Context hook â€” single ## line asking for one stat
  â†“
AI responds: "DEX"
  â†“
Output hook â€” rollCheck() solo branch
resolveRoll("1d20+DEX", Nikolai) â†’ result
notify(breakdown)
text = "## Continue the story. Nikolai attempted to pick the lock. Nikolai rolled 14."
  â†“
AI narrates â€” judges success/failure by context (bank safe vs bathroom cabinet)
```

---

## Tag System Flow

```
World maker creates: [CSMS] Mira card with description entry
    â†“
Context hook â€” processTaggedCards() finds [CSMS] Mira
    â†“
Check recent history â€” does "Mira" appear?
    â†“
YES â€” check for existing CS
    â†“
No CS found â€” set state.csmsPending = "Mira"
Inject stat generation prompt into frontMemory
    â†“
AI responds with: STR:x DEX:x CON:x INT:x WIS:x CHA:x HP:x AC:x
    â†“
Output hook â€” generateNarrativeSheet() detects csmsPending
Parse stats, create character, updateCharacterCard()
Remove [CSMS] tag from original card
Strip stat string from visible output
Clear state.csmsPending
    â†“
Player sees: [Character sheet generated for Mira!] + normal narrative
```

---

## Ordinance System Design (Planned)

### What Are Ordinances
Ordinances are story card-based abilities that allow world builders and players to modify how core mechanics behave â€” without breaking narrative logic. They are conditional rule modifiers that work *with* the existing dice and combat system.

Examples:
- Counter attack on a lost roll â€” even the loser can deal half damage
- Double strike on a won roll â€” winner deals the same damage twice
- Faction leader calls reinforcements once per combat
- Combat style that modifies how damage is calculated

### Philosophy
- **Script's job:** detect ordinance usage, inject ordinance card entry into context, execute dice rolls, apply results
- **AI's job:** read ordinance rules, judge conditions, decide formula, narrate outcome
- World builder writes the rules in natural language â€” AI interprets, script executes

### Ordinance Card Format
Free-form natural language. No fixed structure required. Example:
```
Counter Strike:
When the character loses a roll, they may still deal half damage to the opponent.
Damage = half of opponent's damage roll, rounded down.
Output the roll breakdown before narrating outcome.
```

### Script-AI Contract
AI reads ordinance rules and outputs formula in parseable tag:
```
[ROLL:XdY+Z]     â† any valid dice notation e.g. [ROLL:3d6+2] or [ROLL:1d8+WIS]
[DAMAGE:XdY+Z]   â† damage application e.g. [DAMAGE:2d4+1]
```

Script parses tag â†’ calls `resolveRoll()` â†’ applies result â†’ feeds result back to AI â†’ AI narrates.

### Command (planned)
```
/csms ordinance/OrdinanceName
```

---

## Inventory System Design (v1.6.0+)

### Problem
AID has no native inventory system. Items appear from nowhere, vanish after a few actions, and the AI has no reliable source of truth for what a character is carrying.

### Solution
Inventory lives in the CS story card's Notes field (description in API). Player edits manually, script syncs to state on command. Script injects inventory into context only when the player explicitly calls for it.

### Format
```
[Inventory]
- dark blazer
- BMW keys
- apple smartphone
- $1000 cash
- cracked glass bottle
- glass bottle
- glass bottle
- account ledger
- notes "Player annotation goes here."
```

Each `- item` = one entry. Duplicates are separate lines. Optional `notes "..."` for player annotations.

### State Structure
```js
state.characters[i].inventory = ["dark blazer", "BMW keys", "glass bottle", "glass bottle"]
```

### Responsibility Split
- Player edits the CS notes card manually
- Player runs `/csms update/inventory/Name` to sync
- Script confirms and stores to state
- AI only sees inventory when player explicitly brings it to context
- Mistakes are corrected by the player â€” not restricted by the script

---

## Compatibility Notes

### Inner Self (LewdLeah)
- IS uses `storyCards` directly â€” compatible
- IS uses `state` â€” compatible, use namespaced keys (`state.characters` not `state.char`)
- IS uses `state.memory` â€” compatible, don't overwrite IS memory fields
- Architecture mirrors IS pattern (`InnerSelf("input")` â†’ `CSMS("input")`)

### Auto-Cards
- AC generates cards by character name keywords â€” potential overlap
- Current mitigation: `csms_cs_${name}` prefix on card keys
- Direct `frontMemory` injection makes keyword matching irrelevant for CSMS internals
- Tag system works WITH AC â€” AC generates a card, world maker adds `[CSMS]` tag, CSMS generates sheet

### General compatibility rule
- Always namespace state variables: `state.characters`, `state.notifyMessages` etc
- Never use generic keys that other scripts might use
- `ğŸ“‹` emoji prefix on card titles â€” distinctive enough to avoid conflicts

---

## File Structure
```
src/
  library.js        â€” Main script (NotifyThem + CSMS)
assets/
  Notes.MD          â€” This file
  Milestones.MD     â€” Phase tracking
  Changelog.MD      â€” Version history
  images/
    CSMS_CoverArt.png
README.md           â€” Public documentation
```

---

## Opposed Roll Design (Implemented â€” v1.5.0)

### Why it's needed
Without opposed rolls, NPC attacks have no mechanical weight. HP never updates from NPC actions.

Opposed roll closes the loop:
- Player rolls DEX (dodge) â†’ 6
- Guard rolls STR (attack) â†’ 15
- Guard wins by 9 â†’ hit confirmed by script, HP updates, AI narrates

### DC vs AC vs Opposed (quick reference)
| Type | Example | Both sides roll? |
|---|---|---|
| DC check | Pick a lock (DC 15) | âŒ Player rolls vs fixed number |
| AC check | Attack someone | âŒ Attacker rolls vs defender's static AC |
| Opposed roll | Dodge a punch | âœ… Both sides roll, higher wins |
