# CSMS Technical Notes

## AID Environment Discoveries

### globalThis dump (beta, Feb 2026)
```
"global"
"log"           â† native shorthand for console.log
"sandboxConsole"
"storyCards"    â† direct array manipulation works
"worldInfo"
"updateStoryCards"  â† native but unreliable, use storyCards directly
"updateState"       â† native but behavior unclear, use state directly
"state"
"memory"        â† separate from state.memory, don't write to this
"text"
"info"
"history"
```

### Key Findings
- `log()` is a native global shorthand for `console.log()`
- `storyCards.push()` works for creation, direct mutation works for updates
- `updateStoryCards` â€” tested, unreliable. Stick to direct `storyCards` manipulation
- `updateState` â€” tested, doesn't reflect changes. Use `state.x = y` directly
- `memory` global and `state.memory` are SEPARATE objects. Only write to `state.memory`
- Input text always has newline prefix â€” always `.trim()` before processing
- Script doesn't run if AI stutters/lags â€” player must retry, nothing we can do
- `.includes()` works fine on strings as long as values are sanitized with `|| ""`
- Library functions show up in `globalThis` â€” confirmed by testing `rollDice`

### state.memory
- `state.memory.context` â€” write to this to override Plot Essentials
- `state.memory.authorsNote` â€” write to this to override Author's Note
- `state.memory.frontMemory` â€” injected before last action, invisible to player
- Both readable and writable confirmed

### storyCard object structure
```js
{
  id: "542586357",              // auto-assigned by AID
  createdAt: "2026-02-23...",   // auto-assigned
  updatedAt: "2026-02-23...",   // auto-assigned
  keys: "keyword1, keyword2",
  entry: "card content here",
  type: "",
  title: "Card Title",
  description: "notes field",
  useForCharacterCreation: false  // undocumented field
}
```

### Multiplayer Findings (tested Feb 2026)
- `info.characters` returns **array of strings**, NOT array of objects
  - Documentation says `[{ name: "Sam" }]` â€” THIS IS WRONG
  - Actual format: `["Nikolai", "Datwangye"]`
- All players default to name "You" on join â€” must change manually
- Third Person plot component switches input format from `> You` to `> Name`
- All players see the same output in real-time
- Host model settings apply to all players
- Name changes mid-session don't sync instantly across all screens (AID UI lag)
- Input format in third person: `\n> CharacterName action here`

### Known Bugs / Limitations
- `stop: true` in input modifier also suppresses player action from displaying
- Script Test panel unreliable â€” use PLAY + INSPECT workflow instead
- LMI and logs expire after a few minutes â€” keep second tab open while testing
- `updateWorldEntry` throws error if index doesn't exist (no longer silent)
- Inspect panel (Last AI Call) unreliable â€” use `log()` to verify frontMemory injection

---

## Design Decisions

### Why `state.characters[]` array instead of `state.character`
Multiple characters needed â€” player + NPCs. Array allows `find()`, `findIndex()`, iteration. Single object would require separate storage per character.

### Why `storedName` in handleReset
Player might type "JonaTHan" â€” `findCharacter()` finds it case-insensitively but `removeCharacterCard()` does exact title match. Always use the stored name from state for card operations.

### Why bracketed notifications `[...]`
AI treats bracketed content as out-of-character notes â€” sees it but doesn't narrate it directly. Established AID convention (same as `[Author's note:]`). Keeps narrative clean.

### Why regex scan instead of startsWith for commands
AID prepends `> You` or `> You say, "..."` to do/say inputs. Format changes between versions. Scanning entire input for `/csms` pattern anywhere is future-proof and format-agnostic.

### Why `feedToOutput` removed from notify()
Single responsibility principle. `notify()` just stores messages. `updateNotification()` handles flushing. Cleaner separation.

### Why NotifyThem is separate from CSMS
Independent reusability â€” other scripters can use NotifyThem without CSMS. Publishable as standalone system. Clean separation of concerns.

### Why position-based parsing in parseCharacterCard
Reading values by position instead of label means player can rename any label without breaking the parser. `srt: 14` still gives us `14` for STR. Label is irrelevant â€” structure is what matters.

### Why `\S+` instead of `\d+` in parseCharacterCard regex
`\d+` would fail silently if player types `ee` for a stat value â€” entire line match returns null and `safeInt` never gets called. `\S+` captures anything, lets `safeInt` handle validation and error reporting properly.

### Why `isMultiplayerCharacter` flag
Without it, `syncMultiplayerCharacters()` would delete NPC sheets when they're not in `info.characters`. Flag ensures only actual multiplayer player sheets get synced against the player list.

### Why compact injection format for frontMemory
Full character sheets in frontMemory would consume too much context. One-line format `[CSMS|Name|HP:x/y|AC:z|...]` gives AI all mechanical data it needs in minimum tokens. 20 characters Ã— ~60 chars = ~1200 chars â€” very manageable.

### Why keyword system was deprioritized
AID's native keyword system is unreliable for cross-script compatibility. Direct `frontMemory` injection gives us full control over what the AI sees and when. No keyword conflicts possible.

---

## Command Architecture

```
Player input (any format)
    â†“
Input hook â€” regex scan for /csms anywhere in text
    â†“
parseCommand() â€” extract action and param
    â†“
handle[Action]() â€” execute, return result string
    â†“
notify(result) â€” store in state.notifyMessages
    â†“
Original player text passes to AI unchanged
    â†“
Context hook â€” parseCharacterCard + injectActiveCharacters + syncMultiplayerCharacters
    â†“
AI generates narrative
    â†“
Output hook â€” updateNotification() prepends [brackets] to output
    â†“
Player sees: [CSMS notification] + AI narrative
```

---

## Compatibility Notes

### Inner Self (LewdLeah)
- IS uses `storyCards` directly â€” compatible
- IS uses `state` â€” compatible, use namespaced keys (`state.characters` not `state.char`)
- IS uses `state.memory` â€” compatible, don't overwrite IS memory fields
- Architecture mirrors IS pattern (`InnerSelf("input")` â†’ `CSMS("input")`)
- IS scans history for character triggers â€” same approach as our `LOOKBACK_ACTIONS`

### Auto-Cards
- AC generates cards by character name keywords â€” potential overlap
- Current mitigation: `csms_cs_${name}` prefix on card keys
- Better solution: direct `frontMemory` injection (implemented) makes keyword matching irrelevant for AI context

### General compatibility rule
- Always namespace state variables: `state.characters`, `state.notifyMessages` etc
- Never use generic keys that other scripts might use
- `ðŸ“‹` emoji prefix on card titles â€” distinctive enough to avoid conflicts

---

## File Structure
```
src/
  library.js        â€” Main script (NotifyThem + CSMS)
assets/
  Notes.MD          â€” This file
  Milestones.MD     â€” Phase tracking
  Changelog.MD      â€” Version history
  images/
    CSMS_CoverArt.png
README.md           â€” Public documentation
```

---

## Context Recovery (for new Claude sessions)
Paste this at start of conversation:
*"Here's our AID CSMS project: [library.js](https://raw.githubusercontent.com/NikolaiF90/AIDCharacterSheetandMechanicSystem/refs/heads/main/src/library.js) and [Notes.MD](https://raw.githubusercontent.com/NikolaiF90/AIDCharacterSheetandMechanicSystem/refs/heads/main/assets/Notes.MD). For reference, here's the [AI Dungeon official scripting site](https://help.aidungeon.com/scripting), though it could be outdated. Read all and let's continue from Phase 2."*
